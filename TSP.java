import java.util.*;

public class TSP {
    private int n; // Количество городов
    private int[][] distances; // Матрица расстояний между городами
    private int[][] memo; // Таблица для мемоизации (запоминания вычисленных результатов)

    /**
     * Основной метод для поиска минимальной стоимости маршрута
     * @param distances - матрица расстояний между городами
     * @return минимальная длина маршрута коммивояжера
     */
    public int findMinCost(int[][] distances) {
        this.n = distances.length;
        this.distances = distances;
        
        // Инициализируем таблицу мемоизации
        // Размер: [n] городов × [2^n] возможных комбинаций посещенных городов
        this.memo = new int[n][1 << n]; // 1 << n создает 2^n (битовая маска)
        
        // Заполняем таблицу значением -1 (отмечаем как "еще не вычислено")
        for (int i = 0; i < n; i++) {
            Arrays.fill(memo[i], -1);
        }
        
        // Запускаем рекурсивный поиск:
        // - Начинаем из города 0 (стартовый город)
        // - Маска 1 (двоичное 0001) означает, что посетили только город 0
        return tsp(0, 1);
    }

    /**
     * Рекурсивная функция для решения задачи коммивояжера
     * @param current - текущий город, в котором находимся
     * @param mask - битовая маска посещенных городов
     * @return минимальная стоимость для текущего состояния
     */
    private int tsp(int current, int mask) {
        // БАЗОВЫЙ СЛУЧАЙ: все города посещены
        // (1 << n) - 1 создает маску из n единиц, например для n=4: 1111
        if (mask == (1 << n) - 1) {
            // Возвращаемся в стартовый город (город 0)
            return distances[current][0];
        }
        
        // ПРОВЕРКА МЕМОИЗАЦИИ: если уже вычисляли это состояние, возвращаем результат
        if (memo[current][mask] != -1) {
            return memo[current][mask];
        }
        
        // Инициализируем минимальную стоимость максимально возможным значением
        int minCost = Integer.MAX_VALUE;
        
        // ПЕРЕБОР всех возможных следующих городов
        for (int next = 0; next < n; next++) {
            // Проверяем, не посещали ли мы город 'next' ранее
            // (mask & (1 << next)) == 0 означает, что бит 'next' в маске равен 0
            if ((mask & (1 << next)) == 0) {
                // Создаем новую маску, отмечая город 'next' как посещенный
                int newMask = mask | (1 << next);
                
                // Рекурсивно вычисляем стоимость:
                // 1. Стоимость перехода из current в next
                // 2. Плюс минимальная стоимость из next с новой маской
                int cost = distances[current][next] + tsp(next, newMask);
                
                // Обновляем минимальную стоимость
                minCost = Math.min(minCost, cost);
            }
        }
        
        // Сохраняем результат в таблицу мемоизации перед возвратом
        memo[current][mask] = minCost;
        return minCost;
    }

    // Пример использования
    public static void main(String[] args) {
        TSP solver = new TSP();
        
        // Матрица расстояний между 4 городами
        // distances[i][j] = расстояние от города i до города j
        int[][] distances = {
            // Из города 0 в: 0,  1,  2,  3
            {0, 10, 15, 20},   // Из города 0
            {10, 0, 35, 25},   // Из города 1  
            {15, 35, 0, 30},   // Из города 2
            {20, 25, 30, 0}    // Из города 3
        };
        
        int result = solver.findMinCost(distances);
        System.out.println("Минимальная длина маршрута: " + result);
        System.out.println("Ожидаемый результат: 80");
        System.out.println("Оптимальный маршрут: 0 → 1 → 3 → 2 → 0");
        System.out.println("Проверка: 10 + 25 + 30 + 15 = 80");
    }
}